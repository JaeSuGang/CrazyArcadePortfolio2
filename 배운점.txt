0. 정말 직접 엔진을 만들었다는 증거 = Git으로 남아있는 commit 기록.
엔진이 한번에 생기지 않고 점점 코드가 늘어가며,
중간중간에 적절하게 수정도 됨

1. RAII 방식의 메모리 관리에 익숙해질 수 있었음.
2. 컴포넌트와 상속을 실제로 활용해보며 익숙해질 수 있었음.
3. WinApi를 써보면서, .cpp의 구현없이 라이브러리와 헤더파일만을 이용한
프로그래밍을 이해할 수 있었으며, 핸들, DC, 백버퍼, RGBA 등 렌더의 기초를 배울 수 있었음.
4. 효율적인 자료구조를 실전에서 써볼 수 있었음
actors에는 unordered_set을 사용 (순서와 정렬 필요 x, 삭제에 O(1), 1000개의 AActor*중 500개 삭제 상황)
AActor의 m_Components에는 unordered_map을 사용함 (key값을 typeid(T).name() 하면 원하는 컴포넌트를 Get하는데에 O(1))
렌더링 순서에는 multimap<int, URenderComponent*>을 사용함 (정렬이 필요하므로).
key값이 낮을수록 먼저 렌더링.

5. deltatime은 한 프레임 내에서는 같은 값을 가져야 오류가 나지 않음.
6. Event Delegate에서 AActor의 주소를 bind할때,
루프돌려야할 별도의 AActor 그룹을 만들때 (Manager에서 루프를 돌 AActor* 등),
AActor의 주소를 여기 저기서 보관해야하는 일이 생길때,
AActor를 삭제시켜야 할때마다 이런 주소를 참조해가는 곳을 일일히 신경써주기가 매우 번거로움.
스마트포인터의 Weak_ptr의 필요성을 느낌.

7. SOLID 원칙중 "의존성 역전"의 의미를 FArchive와 ISerializable을 통해서 확인할 수 있었음.
FArchive는 Serialize(ISerializable* Serializable)이라는 함수를 오버로딩 함으로써,
FArchive 매우 추상적이고 원초적인 클래스 임에도 불구하고 구체적인 Concrete한 객체와의 상호작용이
가능했음. 바이너리 데이터의 직렬화와 역직렬화, c 라이브러리 사용법에 대해서도 알게됨