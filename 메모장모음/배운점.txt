0. 정말 직접 엔진을 만들었다는 증거 = Git으로 남아있는 commit 기록.
엔진이 한번에 생기지 않고 점점 코드가 늘어가며,
중간중간에 적절하게 수정도 됨

1. RAII 방식의 메모리 관리에 익숙해질 수 있었음.
2. 컴포넌트와 상속을 실제로 활용해보며 익숙해질 수 있었음.
3. WinApi를 써보면서, .cpp의 구현없이 라이브러리와 헤더파일만을 이용한
프로그래밍을 이해할 수 있었으며, 핸들, DC, 백버퍼, RGBA 등 렌더의 기초를 배울 수 있었음.
4. 효율적인 자료구조를 실전에서 써볼 수 있었음
actors에는 unordered_set을 사용 (순서와 정렬 필요 x, 삭제에 O(1), 1000개의 AActor*중 500개 삭제 상황)
AActor의 m_Components에는 unordered_map을 사용함 (key값을 typeid(T).name() 하면 원하는 컴포넌트를 Get하는데에 O(1))
렌더링 순서에는 연결리스트를 사용. 렌더링 순서에 사용할 자료구조는,
요소 내에 객체가 가진 값들에 따라 요소가 재정렬되야할 수 있음.
단순한 int 자료구조는 한번 정렬하면 끝이지만, 포인터나 객체 자료구조는 그것이 가진 값에 따라
다르게 재정렬이 이루어져야 할 수 있음. 그러므로 map은 부적잘함.
vector의 중간 삭제를 swipe_and_pop 방식을 사용하며, 매 프레임마다 일정 시기에 한번씩 정렬한다는 조건하에
std::vector가 제일 적합함.


5. deltatime은 한 프레임 내에서는 같은 값을 가져야 오류가 나지 않음.
6. Event Delegate에서 AActor의 주소를 bind할때,
루프돌려야할 별도의 AActor 그룹을 만들때 (Manager에서 루프를 돌 AActor* 등),
AActor의 주소를 여기 저기서 보관해야하는 일이 생길때,
AActor를 삭제시켜야 할때마다 이런 주소를 참조해가는 곳을 일일히 신경써주기가 매우 번거로움.
스마트포인터의 Weak_ptr의 필요성을 느낌.

7. SOLID 원칙중 "의존성 역전"의 의미를 FArchive와 ISerializable을 통해서 확인할 수 있었음.
FArchive는 Serialize(ISerializable* Serializable)이라는 함수를 오버로딩 함으로써,
FArchive 매우 추상적이고 원초적인 클래스 임에도 불구하고 구체적인 Concrete한 객체와의 상호작용이
가능했음. 바이너리 데이터의 직렬화와 역직렬화, c 라이브러리 사용법에 대해서도 알게됨

8. Tick으로 시간경과를 지켜봐야하는 로직의 경우, 부하를 줄이기 위해
m_fAccumulatedDeltaTime += fDeltaTime; if (m_AccumulatedfDeltaTime > 0.05f)
등으로 프레임을 방어할수 있었음.

9. A* 길찾기 알고리즘을 사용해 볼 수 있었음. 그에 따라 최소 힙 자료구조를 써볼 수 있었음.
OpenList에 존재하는 노드들 중 휴리스틱 점수가 제일 낮은 노드들 부터 꺼내서 우선 탐색해야 했기 때문에 최소힙이 적합했음.

10. 길찾기 알고리즘에 사용할 노드를 스마트포인터로 만듬으로써, 참조카운트가 0인 노드는 자동으로 사라지게 함.
